#
# ***********************************************************************
#  Warning: This file is auto-generated from main.py.in - edit it there.
# ***********************************************************************
#
#  pybootchartgui is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.

#  pybootchartgui is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.

#  You should have received a copy of the GNU General Public License
#  along with pybootchartgui. If not, see <http://www.gnu.org/licenses/>.

from __future__ import print_function

import sys
import os
import optparse
import string

from copy import copy
from optparse import Option, OptionValueError

from . import parsing
from . import batch
from . import writer
from .samples import EventSource, EventColor

def _mk_options_parser():
	"""Make an options parser."""
	usage = "%prog [options] PATH"
	version = "%prog v@VER@"
	parser = optparse.OptionParser(usage=usage, version=version,
				       description="PATH must point to a bootchart*.tgz",
				       epilog=None)
	parser.add_option("--batch", action="store_false", dest="interactive", default=True,
			  help="print a bootchart image, rather than starting the interactive GUI")
	parser.add_option("--absolute-uptime-event-times", action="store_true", default=False,
                          dest="absolute_uptime_event_times",
			  help="event times shown are relative to system boot, rather than beginning of sampling")
	parser.add_option("-H", "--hide-low-CPU", dest="hide_low_CPU", type="int", default=0, metavar="CSEC",
			  help="Hide any thread consuming less than CSEC of CPU time, unless it otherwise shows itself to be of interest." +
                          "  Hiding means the thread is not shown on initial rendering, but can be shown by a mouse click." +
			  "  A value of 0 may be specified, meaning the special case of showing threads that report 0 CSECs" +
			  " consumed, but are known to have executed due to having been born, died, or reported some" +
			  " state other than 'S' when sampled by the collector." +
			  "  A negative value causes all threads to be shown.")
	parser.add_option("-q", "--quiet", action="store_true", dest="quiet", default=False,
			  help="suppress informational messages")
	parser.add_option("-v", "--verbose", action="count", dest="verbose", default=0,
			  help="Print debugging messages.  Issuing twice will print yet more messages.")
	parser.add_option("--show-legends", action="store_true", dest="show_legends", default=False,
			  help="show legend lines with keys to chart symbols")

        # disk stats
	parser.add_option("--partition", action="append", dest="partitions", type="string", default=[],
			  help="draw a disk stat chart for any block device partition whose basename matches PARTITION")
	parser.add_option("--relabel-partition", action="append", dest="partition_labels", default=[],
			  help="list of per-partition strings, each replacing the raw per-partition device name" +
                          "in the corresponding position")
	parser.add_option("--show-ops-not-bytes", action="store_true", dest="show_ops_not_bytes", default=False,
			  help="chart number of I/O operations handed to driver, rather than bytes transferred per sample")

	parser.add_option("--show-pid", action="store_true", dest="show_pid", default=False,
			  help="show process ids in the bootchart as 'processname [pid]'")
	parser.add_option("-j", "--justify", dest="justify", default="left", choices=["left", "center"],
			  help="relocate the text within process bars (left, center)")

	# event plotting
	parser.set_defaults(event_source = [])
	parser.add_option("--event-source",
			  action="callback", callback=handle_event_source_option, type="string", nargs=3,
			  help="Tell pybootchartgui which file in the tarball contains event records," +
			  "and how to extract the four essential fields from it." +
                          "  A 3-tuple of (label,filename,regex) does the job, e.g.:" +
                          "   --event-source usec-format log-file-in-tarball.txt 'usec_bits=(?P<CLOCK_REALTIME_usec>[^,]+),\Wpid=(?P<pid>[^,]+),\Wtid=(?P<tid>[^,]+),\Wcomm=(?P<comm>[^,]+)'" +
			  "N.B.: The '_' character is unusable in labels, as the PyGTK toolkit silently discards it.")

	parser.set_defaults(event_color = [])
	parser.add_option("-e", "--events", nargs=2, type="string",
			  action="callback", callback=handle_event_color,
			  metavar="REGEX", help="Highlight events matching REGEX." +
                          "  2-tuple of (label-string, REGEX)." +
			  "  Regex syntax is similar to grep 'extended' REs." +
                          "  To match FOO or BAR anywhere on the log line, use 'FOO|BAR'." +
                          "  (file:///usr/share/doc/python/html/library/re.htm)")
	parser.set_defaults(event_interval_color = [])
	parser.add_option("--events-interval", nargs=3, type="string",
			  action="callback", callback=handle_event_interval_color,
			  metavar="REGEX", help="3-tuple of (label-string, REGEX_start, REGEX_end)." +
			  "In addition to highlighting the events matching the two REGEX arguments, " +
                          "  highlight the interval of time between them.")
	parser.add_option('-d', "--events-disable",
			  action="callback", callback=handle_events_disable, type="string", nargs=1,
			  help="Disable event-parsing regex matching (label) -- its checkbox on the Ev-Color menu will be cleared." +
			  "  Must appear after the option that specified (label).")

	parser.add_option("--hide-events", action="store_true", dest="hide_events", default=False,
			  help="hide event ticks (small black triangles)")
	parser.add_option("--no-print-event-times", action="store_false", default=True, dest="print_event_times",
			  help="suppress printing time of each event, inside the box of the reporting process")

	parser.add_option("--dump-raw-event-context", action="store_true", dest="dump_raw_event_context", default=False,
			  help="in addition to log lines for selected events, dump log lines as well," +
                          " retaining original log sort order, which may not be temporally correct.")

	parser.add_option("--no-synthesize-sample-start-events", action="store_false", default=True,
                          dest="synthesize_sample_start_events",
			  help="disable synthesis of an event marking each boundary between sample periods." +
                          "These are helpful in analyzing collector timing issues.")

	pg_Bootchart2 = optparse.OptionGroup(parser,"Bootchart2-specific",
			    "Options effective only for logs coming from the Bootchart2 binary-format collector")
	pg_Bootchart2.add_option("--show-all", action="store_true", dest="show_all", default=False,
			  help="show all process information in the bootchart as '/process/path/exe [pid] [args]'")
	parser.add_option_group(pg_Bootchart2)

	pg_Scripting = optparse.OptionGroup(parser,"Scripting support",
			    "Options most useful in scripted processing of tgz batches")

	pg_Scripting.add_option("--merge", dest="merge", default=False,
			  help="Prune the process tree of all activity from dull children: " +
                          "stats are added to parent, child process is lost in drawing of chart.")
	pg_Scripting.add_option("--prehistory", action="store_true", dest="prehistory", default=False,
			  help="extend process bars to the recorded start time of each, even if before any samples were collected")
	pg_Scripting.add_option("-t", "--boot-time", action="store_true", dest="boottime", default=False,
			  help="only display the boot time of the boot in text format (stdout)")
	pg_Scripting.add_option("-f", "--format", dest="format", default="png", choices=["png", "svg", "pdf"],
			  help="image format (png, svg, pdf); default format png")
	pg_Scripting.add_option("--very-quiet", action="store_true", dest="veryquiet", default=False,
			  help="suppress all messages except errors")
	pg_Scripting.add_option("-o", "--output", dest="output", metavar="PATH", default=None,
			  help="output path (file or directory) where charts are stored")
	pg_Scripting.add_option("--profile", action="store_true", dest="profile", default=False,
			  help="profile rendering of chart (only useful when in batch mode indicated by -f)")
	pg_Scripting.add_option("--crop-after", dest="crop_after", metavar="PROCESS", default=None,
			  help="crop chart when idle after PROCESS is started")
	pg_Scripting.add_option("--annotate", action="append", dest="annotate", metavar="PROCESS", default=None,
			  help="annotate position where PROCESS is started; can be specified multiple times. " +
			       "To create a single annotation when any one of a set of processes is started, use commas to separate the names")
	pg_Scripting.add_option("--annotate-file", dest="annotate_file", metavar="FILENAME", default=None,
			  help="filename to write annotation points to")
	parser.add_option_group(pg_Scripting)
	return parser

def _get_filename(paths, options):
	"""Construct a usable filename for outputs based on the paths and options given on the commandline."""
	dname = ""
	fname = "bootchart"

	if not options.output:
		options.output = '.'.join([fname, options.format])

	if not os.path.isdir(options.output):
		return options.output

	dname = options.output
	if len (paths) == 1:
		path = paths[0]
		if os.path.isdir(path):
			fname = os.path.split(path)[-1]
		elif os.path.splitext(path)[1] in [".tar", ".tgz", ".tar.gz"]:
			fname = os.path.splitext(path)[0]
			# strip directory
			fname = os.path.split(fname)[-1]
	return os.path.join (dname, fname + "." + options.format)

def handle_event_source_option(option, opt_str, value, parser):
	# XX  superfluous: note that pdb `print value[1]` will double-print '\' characters
	#    fix = string.replace(value[1], r"\\", "\x5c")
	parser.values.event_source.append(
		EventSource(value[0], value[1], value[2]))

def handle_event_color(option, opt_str, value, parser):
	ec = EventColor(value[0], value[1], None, True)
	parser.values.event_color.append(ec)

def handle_event_interval_color(option, opt_str, value, parser):
	ec = EventColor(value[0], value[1], value[2], True)
	parser.values.event_interval_color.append(ec)

def handle_events_disable(option, opt_str, value, parser):
	for ec in parser.values.event_color + parser.values.event_interval_color:
		if ec.label == value:
			ec.enable = False
			return
	raise parsing.ParseError("Event-Color label {1:s} not found\n\t{0:s}".format(
			opt_str, value))

def main(argv=None):
	try:
		if argv is None:
			argv = sys.argv[1:]
	
		parser = _mk_options_parser()
		options, args = parser.parse_args(argv)
		writer.init(options)

		if len(args) == 0:
			raise parsing.ParseError("\n\tNo path to a bootchart.tgz found on command line")

		res = parsing.Trace(args, options)

		if options.interactive:
			from . import gui
			gui.show(res, options)
		elif options.boottime:
			import math
			proc_tree = res.proc_tree
			if proc_tree.idle:
			    duration = proc_tree.idle
			else:
			    duration = proc_tree.duration()
			dur = duration / 100.0
			print('%02d:%05.2f' % (math.floor(dur/60), dur - 60 * math.floor(dur/60)))
		else:
			if options.annotate_file:
				f = open (options.annotate_file, "w")
				try:
					for time in res[4]:
						if time is not None:
							# output as ms
							print(time * 10, file=f)
						else:
							print(file=f)
				finally:
					f.close()
			filename = _get_filename(args, options)
			def render():
				batch.render(res, options, filename)
			if options.profile:
				import cProfile
				import pstats
				profile = '%s.prof' % os.path.splitext(filename)[0]
				cProfile.runctx('render()', globals(), locals(), profile)
				p = pstats.Stats(profile)
				p.strip_dirs().sort_stats('time').print_stats(20)
			else:
				render()

		return 0
	except parsing.ParseError as ex:
		print(("Parse error: %s" % ex))
		return 2


if __name__ == '__main__':
	sys.exit(main())
